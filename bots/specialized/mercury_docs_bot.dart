import 'dart:io';
import '../core/bot_base.dart';

/// Bot de documentaci√≥n Mercury
class MercuryDocsBot extends AutomationBot {
  @override
  String get name => 'Mercury Docs Bot';

  @override
  String get emoji => 'üìö';

  @override
  String get role => 'Documentation Curator';

  @override
  BotPriority get priority => BotPriority.medium;

  @override
  Future<BotResult> execute(BotContext context) async {
    final startTime = DateTime.now();
    log('Curating documentation...');

    try {
      final results = <String, dynamic>{};

      // 1. Generar docs de bots
      log('Generating bot documentation...');
      final botDocsResult = await _generateBotDocs();
      results['bot_docs'] = botDocsResult;

      // 2. Actualizar README si es necesario
      if (context.getConfig<bool>('update_readme', defaultValue: false)) {
        log('Updating README...');
        final readmeResult = await _updateReadme();
        results['readme'] = readmeResult;
      }

      // 3. Generar documentaci√≥n de API (dartdoc)
      if (context.getConfig<bool>('generate_api_docs', defaultValue: false)) {
        log('Generating API documentation...');
        final apiDocsResult = await _generateApiDocs();
        results['api_docs'] = apiDocsResult;
      }

      final duration = DateTime.now().difference(startTime);
      log('‚úÖ Documentation updated successfully');

      return BotResult.success(
        message: 'Documentation generation completed',
        data: results,
        duration: duration,
      );
    } catch (e, st) {
      final duration = DateTime.now().difference(startTime);
      return BotResult.failure(
        message: 'Documentation generation failed',
        error: e.toString(),
        stackTrace: st,
        duration: duration,
      );
    }
  }

  Future<Map<String, dynamic>> _generateBotDocs() async {
    try {
      final docsGenerated = <String>[];

      // Leer registro de bots
      final registryFile = File('bots/registry/bot_registry.yaml');
      
      if (!await registryFile.exists()) {
        return {
          'status': 'skipped',
          'message': 'Bot registry not found',
        };
      }

      final registryContent = await registryFile.readAsString();
      
      // Parseo simple de YAML (para los bots principales)
      final botNames = ['atlas', 'oracle', 'sentinel', 'scout', 'zen', 'phoenix', 'mercury', 'guardian'];

      for (final botName in botNames) {
        if (registryContent.contains('$botName:')) {
          await _generateBotDocFile(botName, registryContent);
          docsGenerated.add(botName);
        }
      }

      return {
        'status': 'success',
        'docs_generated': docsGenerated.length,
        'bots': docsGenerated,
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }

  Future<void> _generateBotDocFile(String botName, String registryContent) async {
    // Extraer informaci√≥n b√°sica del bot
    final botSection = _extractBotSection(botName, registryContent);
    
    final docContent = '''
# $botName Bot

## Overview
Automated bot for the Tokyo Roulette Predictor project.

## Configuration
See `bots/registry/bot_registry.yaml` for full configuration.

## Bot Section
```yaml
$botSection
```

## Usage
This bot is triggered automatically based on the configured triggers in the registry.

## Capabilities
See the registry file for the complete list of capabilities.

---
*This documentation was automatically generated by Mercury Docs Bot*
''';

    final docFile = File('docs/library/bots/individual-bots/$botName-bot.md');
    await docFile.create(recursive: true);
    await docFile.writeAsString(docContent);
  }

  String _extractBotSection(String botName, String content) {
    // Extracci√≥n simple de la secci√≥n del bot
    final lines = content.split('\n');
    final botLines = <String>[];
    var inBotSection = false;
    var indentLevel = 0;

    for (final line in lines) {
      if (line.trim().startsWith('$botName:')) {
        inBotSection = true;
        indentLevel = line.indexOf(botName);
        botLines.add(line);
      } else if (inBotSection) {
        final currentIndent = line.length - line.trimLeft().length;
        
        if (line.trim().isEmpty) {
          continue;
        }
        
        if (currentIndent > indentLevel) {
          botLines.add(line);
        } else {
          break;
        }
      }
    }

    return botLines.join('\n');
  }

  Future<Map<String, dynamic>> _updateReadme() async {
    try {
      final readmeFile = File('README.md');
      
      if (!await readmeFile.exists()) {
        return {
          'status': 'skipped',
          'message': 'README.md not found',
        };
      }

      // Aqu√≠ se podr√≠a actualizar secciones espec√≠ficas del README
      // Por ahora solo verificamos que exista

      return {
        'status': 'success',
        'message': 'README verified',
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> _generateApiDocs() async {
    try {
      final result = await Process.run(
        'dart',
        ['doc', '.'],
      );

      if (result.exitCode == 0) {
        return {
          'status': 'success',
          'output_dir': 'doc/api',
        };
      }

      return {
        'status': 'failed',
        'error': result.stderr.toString(),
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }
}
