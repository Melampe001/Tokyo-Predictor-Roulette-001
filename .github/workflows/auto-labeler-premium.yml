name: Auto-Labeler Premium Bot

# Automatically label PRs and issues based on content and file changes

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]
  issues:
    types: [opened, edited]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  auto-label:
    name: Auto Label PRs and Issues
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        if: github.event_name == 'pull_request'
      
      - name: Label based on file changes (PRs)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.issue.number;
            
            // Get PR files
            const { data: files } = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: pr_number,
            });
            
            const labels = new Set();
            
            // Analyze file changes
            for (const file of files) {
              const path = file.filename;
              
              // Backend/Python
              if (path.endsWith('.py')) {
                labels.add('backend');
                if (path.includes('model') || path.includes('predictor')) {
                  labels.add('ml-model');
                }
              }
              
              // Frontend/Flutter/Dart
              if (path.endsWith('.dart')) {
                labels.add('mobile');
                labels.add('frontend');
              }
              
              // API changes
              if (path.includes('api') || path.includes('endpoint')) {
                labels.add('api');
              }
              
              // Documentation
              if (path.endsWith('.md') || path.includes('docs/')) {
                labels.add('documentation');
              }
              
              // Tests
              if (path.includes('test') || path.includes('spec')) {
                labels.add('tests');
              }
              
              // CI/CD
              if (path.includes('.github/workflows')) {
                labels.add('ci-cd');
              }
              
              // Configuration
              if (path.includes('config') || path.endsWith('.yaml') || path.endsWith('.yml')) {
                labels.add('configuration');
              }
            }
            
            // Add labels if found
            if (labels.size > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pr_number,
                labels: Array.from(labels),
              });
              
              console.log(`Added labels: ${Array.from(labels).join(', ')}`);
            }
      
      - name: Label based on PR title and description
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.issue.number;
            const title = context.payload.pull_request.title.toLowerCase();
            const body = (context.payload.pull_request.body || '').toLowerCase();
            const content = `${title} ${body}`;
            
            const labels = [];
            
            // Type labels
            if (content.match(/\b(fix|bug|error|crash|issue)\b/)) {
              labels.push('bug');
            }
            if (content.match(/\b(feat|feature|add|new|implement)\b/)) {
              labels.push('enhancement');
            }
            if (content.match(/\b(refactor|cleanup|improve|optimize)\b/)) {
              labels.push('refactor');
            }
            if (content.match(/\b(docs|documentation|readme)\b/)) {
              labels.push('documentation');
            }
            if (content.match(/\b(security|vulnerability|cve)\b/)) {
              labels.push('security');
            }
            if (content.match(/\b(performance|speed|slow|optimize)\b/)) {
              labels.push('performance');
            }
            
            // Priority labels
            if (content.match(/\b(critical|urgent|asap|hotfix)\b/)) {
              labels.push('priority: high');
            } else if (content.match(/\b(important|soon)\b/)) {
              labels.push('priority: medium');
            } else {
              labels.push('priority: low');
            }
            
            // Size estimation
            const additions = context.payload.pull_request.additions || 0;
            const deletions = context.payload.pull_request.deletions || 0;
            const changes = additions + deletions;
            
            if (changes < 10) {
              labels.push('size: XS');
            } else if (changes < 50) {
              labels.push('size: S');
            } else if (changes < 200) {
              labels.push('size: M');
            } else if (changes < 500) {
              labels.push('size: L');
            } else {
              labels.push('size: XL');
            }
            
            // Add labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pr_number,
                labels: labels,
              });
              
              console.log(`Added labels: ${labels.join(', ')}`);
            }
      
      - name: Label issues based on content
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;
            const title = context.payload.issue.title.toLowerCase();
            const body = (context.payload.issue.body || '').toLowerCase();
            const content = `${title} ${body}`;
            
            const labels = [];
            
            // Type labels
            if (content.match(/\b(bug|error|crash|broken|fail)\b/)) {
              labels.push('bug');
            } else if (content.match(/\b(feature|enhancement|add|implement|suggestion)\b/)) {
              labels.push('enhancement');
            } else if (content.match(/\b(question|help|how)\b/)) {
              labels.push('question');
            }
            
            // Component labels
            if (content.match(/\b(mobile|flutter|dart|app)\b/)) {
              labels.push('mobile');
            }
            if (content.match(/\b(backend|server|api|python)\b/)) {
              labels.push('backend');
            }
            if (content.match(/\b(model|prediction|ml|ai)\b/)) {
              labels.push('ml-model');
            }
            if (content.match(/\b(docs|documentation)\b/)) {
              labels.push('documentation');
            }
            
            // Priority labels
            if (content.match(/\b(critical|urgent|asap|blocker)\b/)) {
              labels.push('priority: high');
            } else if (content.match(/\b(important|soon)\b/)) {
              labels.push('priority: medium');
            } else {
              labels.push('priority: low');
            }
            
            // Special labels
            if (content.match(/\b(security|vulnerability|exploit)\b/)) {
              labels.push('security');
            }
            if (content.match(/\b(performance|slow|lag)\b/)) {
              labels.push('performance');
            }
            if (content.match(/\b(good first issue|beginner|starter)\b/)) {
              labels.push('good first issue');
            }
            
            // Add labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issue_number,
                labels: labels,
              });
              
              console.log(`Added labels: ${labels.join(', ')}`);
            }
      
      - name: Add helpful comment to PR
        if: github.event_name == 'pull_request' && github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.issue.number;
            
            const comment = `## ðŸ¤– Auto-Labeler Bot

Thanks for your pull request! I've automatically added labels based on your changes.

### ðŸ“‹ Checklist
Before merging, please ensure:
- [ ] Tests pass locally
- [ ] Code follows style guidelines
- [ ] Documentation is updated (if needed)
- [ ] No security vulnerabilities introduced

### ðŸ” Need Review?
Your PR will be automatically reviewed by our code quality bot. Address any feedback before requesting human review.

---
*This is an automated message from the Auto-Labeler Premium Bot*`;
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pr_number,
              body: comment,
            });
      
      - name: Auto-assign reviewers
        if: github.event_name == 'pull_request' && github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = context.issue.number;
            
            // Get PR files to determine appropriate reviewers
            const { data: files } = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: pr_number,
            });
            
            const reviewers = new Set();
            
            // Assign based on file types
            for (const file of files) {
              if (file.filename.endsWith('.dart')) {
                // Flutter expert reviewers
                // reviewers.add('flutter-expert-username');
              }
              if (file.filename.endsWith('.py')) {
                // Python/ML expert reviewers
                // reviewers.add('python-expert-username');
              }
              if (file.filename.includes('.github/workflows')) {
                // DevOps expert reviewers
                // reviewers.add('devops-expert-username');
              }
            }
            
            // Note: Uncomment when you have specific reviewers configured
            /*
            if (reviewers.size > 0) {
              await github.rest.pulls.requestReviewers({
                owner,
                repo,
                pull_number: pr_number,
                reviewers: Array.from(reviewers),
              });
              
              console.log(`Assigned reviewers: ${Array.from(reviewers).join(', ')}`);
            }
            */
            
            console.log('Auto-assign reviewers: Configure usernames in workflow to enable');
